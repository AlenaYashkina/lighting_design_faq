import logging
from aiogram import Bot, Dispatcher, types
from aiogram.utils import executor
from sentence_transformers import SentenceTransformer, util
import torch

# Настройки бота
API_TOKEN = "YOUR_API_TOKEN"

# Логирование
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)

# Загрузка модели SentenceTransformer
logger.info("Загрузка модели SentenceTransformer...")
try:
    embedder = SentenceTransformer("multi-qa-mpnet-base-dot-v1")  # Модель, оптимизированная для задач вопросов-ответов  # Более мощная модель для максимальной точности
    logger.info("Модель SentenceTransformer успешно загружена.")
except Exception as e:
    logger.error(f"Ошибка загрузки модели: {e}")
    raise

# База вопросов и ответов
faq = {
    "Что нужно для того, чтобы сделать визуализацию?": "Нужны планы и фасады в .dwg, желательно 3d модель с текстурами, фото.",
    "Что нужно для светотехнического расчёта (СТР)?": "Нужна 3d модель. Если модели нет, то её нужно будет построить (для этого нужны планы и фасады в .dwg и крайне желательно фотографии или адрес для просмотра панорам).",
    "Когда Евремова отгрузят?": "Маша отгрузит светильники ориентировочно 27 декабря 2024.",
    "В каком формате нужна 3d модель?": "В любом (.3ds, .fbx, .obj, .max и т.д.).",
    "Можем ли сделать без чертежей?": "Только если будут замеры точные всех архитектурных элементов, чтобы я могла сначала нарисовать планы и фасады по этим замерам, а потом уже построить модель, сделать визуалки и СТР. Если СТР и проект ЭОМ не нужны, то тогда можем сделать дизайн-проект в Photoshop на фото",
    "Какие фото нужны для того, чтобы сделать визуализацию в Photoshop?": "Дневные фото в НЕсолнечную погоду, чтобы не было теней. На ночных фотографиях сделать дизайн будет невозможно. С тенями на дневных фото можно сделать, но качество будет хуже. Разрешение должно быть хорошее, без мазни. И камеру протирайте обязательно перед тем как делать фото.",
    "Что нужно для проектирования?": "Для проектирования нужны исходные данные: планы и фасады в .dwg, 3D модель с текстурами или фото/адрес для просмотра на панорамах.",
    "Какой формат файла подходит для чертежей?": "Чертежи лучше всего предоставлять в формате .dwg. Это ускоряет процесс работы. Потому что если будет фото или pdf, то придётся в любом случае рисовать чертежи самостоятельно. Это долго и неточно выйдет.",
    "Что делать, если чертежей нет?": "Если чертежей нет, нужны детальные замеры объекта и фотографии со всех возможных ракупсов перпендикулярно к поверхности чтоб камера была (чем кривее будет камера, тем кривее получатся чертежи и модель).",
    "Что потребуется для моделирования объекта?": "Для моделирования нужны планы и фасады в .dwg, материалы отделки и желательно фото.",
    "Сколько времени занимает моделирование?": "Сроки зависят от сложности объекта. В среднем, 1-2 недели.",
    "Какие требования к 3D моделям?": "Требований нет. Пусть присылают что есть, я посмотрю и скажу если что-то не так.",
    "Будет ли засветка?": "Зависит только от вредности соседей. Норм не существует таких.",
    "Сколько времени занимает рендеринг?": "Рендеринг занимает от нескольких часов до нескольких дней, в зависимости от сложности сцены.",
    "Можем ли подобрать и продать светильники без визуализации, проекта, СТР?": "Можем, но потом заказчик может сказать ой, я думаю по-другому будет.",
    "Какие программы используются для расчётов?": "Визуализации делаю либо в Photoshop по фото, либо на 3D модели в 3ds max. Светотехнические расчёты - в Dialux.",
    "Заказчику не нравится": "Узнай что не нравится и давай вместе подумаем что исправить, чтобы понимать что конкретно не понравилось и исправлять только это, а не выдавать по 100500 вариантов."
}

# Предварительное преобразование FAQ в эмбеддинги
faq_questions = list(faq.keys())
faq_answers = list(faq.values())
faq_embeddings = embedder.encode(faq_questions, convert_to_tensor=True)

@dp.message_handler(commands=['start', 'help'])
async def send_welcome(message: types.Message):
    logger.info(f"Получена команда: {message.text} от пользователя {message.from_user.id}")
    await message.reply("Привет! Спроси меня что угодно, и я постараюсь ответить.")

@dp.message_handler()
async def handle_message(message: types.Message):
    user_question = message.text
    logger.info(f"Получен вопрос: {user_question} от пользователя {message.from_user.id}")
    try:
        # Преобразуем вопрос пользователя в эмбеддинг
        question_embedding = embedder.encode(user_question, convert_to_tensor=True)

        # Сравниваем с базой вопросов
        cos_scores = util.pytorch_cos_sim(question_embedding, faq_embeddings)[0]
        top_match_idx = torch.argmax(cos_scores).item()
        score = cos_scores[top_match_idx].item()

        # Проверка на порог схожести
        if score > 0.85:
            response = faq_answers[top_match_idx]
        else:
            response = "Извините, я не смог найти точный ответ на ваш вопрос. Попробуйте переформулировать."

        logger.info(f"Ответ на вопрос: {response} (схожесть: {score:.2f})")
    except Exception as e:
        response = "Извините, я не смог обработать ваш запрос. Попробуйте задать вопрос по-другому."
        logger.error(f"Ошибка обработки вопроса: {e}")

    await message.reply(response)

if __name__ == '__main__':
    logger.info("Запуск бота...")
    try:
        executor.start_polling(dp, skip_updates=True)
    except Exception as e:
        logger.critical(f"Критическая ошибка: {e}")
